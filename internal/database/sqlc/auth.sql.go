// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: auth.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateAuthSession = `-- name: CreateAuthSession :one
INSERT INTO auth_session (id, user_id, refresh_token_hash, ip_address, device_name, user_agent, os_info, expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, refresh_token_hash, ip_address, device_name, user_agent, os_info, 
          is_active, created_at, expires_at
`

type CreateAuthSessionParams struct {
	ID               string             `db:"id" json:"id"`
	UserID           string             `db:"user_id" json:"user_id"`
	RefreshTokenHash string             `db:"refresh_token_hash" json:"refresh_token_hash"`
	IpAddress        string             `db:"ip_address" json:"ip_address"`
	DeviceName       *string            `db:"device_name" json:"device_name"`
	UserAgent        *string            `db:"user_agent" json:"user_agent"`
	OsInfo           *string            `db:"os_info" json:"os_info"`
	ExpiresAt        pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
}

func (q *Queries) CreateAuthSession(ctx context.Context, db DBTX, arg *CreateAuthSessionParams) (*AuthSession, error) {
	row := db.QueryRow(ctx, CreateAuthSession,
		arg.ID,
		arg.UserID,
		arg.RefreshTokenHash,
		arg.IpAddress,
		arg.DeviceName,
		arg.UserAgent,
		arg.OsInfo,
		arg.ExpiresAt,
	)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.DeviceName,
		&i.UserAgent,
		&i.OsInfo,
		&i.IsActive,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const CreateAuthUser = `-- name: CreateAuthUser :one
INSERT INTO users (id, email, name, password_hash, email_verified, vendor_id, country, city, 
                   is_active, is_disabled, enable_social_login, signup_source)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, email, name, password_hash, email_verified, vendor_id, country, city, 
          is_active, is_disabled, enable_social_login, signup_source, created_at
`

type CreateAuthUserParams struct {
	ID                string  `db:"id" json:"id"`
	Email             string  `db:"email" json:"email"`
	Name              *string `db:"name" json:"name"`
	PasswordHash      string  `db:"password_hash" json:"password_hash"`
	EmailVerified     *bool   `db:"email_verified" json:"email_verified"`
	VendorID          string  `db:"vendor_id" json:"vendor_id"`
	Country           *string `db:"country" json:"country"`
	City              *string `db:"city" json:"city"`
	IsActive          *bool   `db:"is_active" json:"is_active"`
	IsDisabled        *bool   `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool   `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string `db:"signup_source" json:"signup_source"`
}

type CreateAuthUserRow struct {
	ID                string             `db:"id" json:"id"`
	Email             string             `db:"email" json:"email"`
	Name              *string            `db:"name" json:"name"`
	PasswordHash      string             `db:"password_hash" json:"password_hash"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateAuthUser(ctx context.Context, db DBTX, arg *CreateAuthUserParams) (*CreateAuthUserRow, error) {
	row := db.QueryRow(ctx, CreateAuthUser,
		arg.ID,
		arg.Email,
		arg.Name,
		arg.PasswordHash,
		arg.EmailVerified,
		arg.VendorID,
		arg.Country,
		arg.City,
		arg.IsActive,
		arg.IsDisabled,
		arg.EnableSocialLogin,
		arg.SignupSource,
	)
	var i CreateAuthUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const CreateVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO verification_token (id, user_id, token_type, valid_till)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, token_type, created_at, valid_till
`

type CreateVerificationTokenParams struct {
	ID        string             `db:"id" json:"id"`
	UserID    string             `db:"user_id" json:"user_id"`
	TokenType string             `db:"token_type" json:"token_type"`
	ValidTill pgtype.Timestamptz `db:"valid_till" json:"valid_till"`
}

func (q *Queries) CreateVerificationToken(ctx context.Context, db DBTX, arg *CreateVerificationTokenParams) (*VerificationToken, error) {
	row := db.QueryRow(ctx, CreateVerificationToken,
		arg.ID,
		arg.UserID,
		arg.TokenType,
		arg.ValidTill,
	)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.CreatedAt,
		&i.ValidTill,
	)
	return &i, err
}

const DeactivateAuthSession = `-- name: DeactivateAuthSession :exec
UPDATE auth_session 
SET is_active = FALSE
WHERE id = $1
`

func (q *Queries) DeactivateAuthSession(ctx context.Context, db DBTX, id string) error {
	_, err := db.Exec(ctx, DeactivateAuthSession, id)
	return err
}

const DeactivateExpiredSessions = `-- name: DeactivateExpiredSessions :exec
UPDATE auth_session 
SET is_active = FALSE
WHERE expires_at <= NOW() AND is_active = TRUE
`

func (q *Queries) DeactivateExpiredSessions(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, DeactivateExpiredSessions)
	return err
}

const DeactivateUserSessions = `-- name: DeactivateUserSessions :exec
UPDATE auth_session 
SET is_active = FALSE
WHERE user_id = $1
`

func (q *Queries) DeactivateUserSessions(ctx context.Context, db DBTX, userID string) error {
	_, err := db.Exec(ctx, DeactivateUserSessions, userID)
	return err
}

const DeleteExpiredTokens = `-- name: DeleteExpiredTokens :exec
DELETE FROM verification_token 
WHERE valid_till <= NOW()
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context, db DBTX) error {
	_, err := db.Exec(ctx, DeleteExpiredTokens)
	return err
}

const DeleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM verification_token 
WHERE id = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, db DBTX, id string) error {
	_, err := db.Exec(ctx, DeleteVerificationToken, id)
	return err
}

const FindUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, name, password_hash, email_verified, vendor_id, country, city, 
       is_active, is_disabled, enable_social_login, signup_source, created_at
FROM users 
WHERE email = $1 AND vendor_id = $2 AND is_active = true
`

type FindUserByEmailParams struct {
	Email    string `db:"email" json:"email"`
	VendorID string `db:"vendor_id" json:"vendor_id"`
}

type FindUserByEmailRow struct {
	ID                string             `db:"id" json:"id"`
	Email             string             `db:"email" json:"email"`
	Name              *string            `db:"name" json:"name"`
	PasswordHash      string             `db:"password_hash" json:"password_hash"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) FindUserByEmail(ctx context.Context, db DBTX, arg *FindUserByEmailParams) (*FindUserByEmailRow, error) {
	row := db.QueryRow(ctx, FindUserByEmail, arg.Email, arg.VendorID)
	var i FindUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const FindUserByID = `-- name: FindUserByID :one
SELECT id, email, name, password_hash, email_verified, vendor_id, country, city, 
       is_active, is_disabled, enable_social_login, signup_source, created_at
FROM users 
WHERE id = $1
`

type FindUserByIDRow struct {
	ID                string             `db:"id" json:"id"`
	Email             string             `db:"email" json:"email"`
	Name              *string            `db:"name" json:"name"`
	PasswordHash      string             `db:"password_hash" json:"password_hash"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) FindUserByID(ctx context.Context, db DBTX, id string) (*FindUserByIDRow, error) {
	row := db.QueryRow(ctx, FindUserByID, id)
	var i FindUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const GetAuthSessionByID = `-- name: GetAuthSessionByID :one
SELECT id, user_id, refresh_token_hash, ip_address, device_name, user_agent, os_info,
       is_active, created_at, expires_at
FROM auth_session 
WHERE id = $1
`

func (q *Queries) GetAuthSessionByID(ctx context.Context, db DBTX, id string) (*AuthSession, error) {
	row := db.QueryRow(ctx, GetAuthSessionByID, id)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.DeviceName,
		&i.UserAgent,
		&i.OsInfo,
		&i.IsActive,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const GetAuthSessionByToken = `-- name: GetAuthSessionByToken :one
SELECT id, user_id, refresh_token_hash, ip_address, device_name, user_agent, os_info,
       is_active, created_at, expires_at
FROM auth_session 
WHERE refresh_token_hash = $1 AND is_active = TRUE AND expires_at > NOW()
`

func (q *Queries) GetAuthSessionByToken(ctx context.Context, db DBTX, refreshTokenHash string) (*AuthSession, error) {
	row := db.QueryRow(ctx, GetAuthSessionByToken, refreshTokenHash)
	var i AuthSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.IpAddress,
		&i.DeviceName,
		&i.UserAgent,
		&i.OsInfo,
		&i.IsActive,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return &i, err
}

const GetUserActiveSessions = `-- name: GetUserActiveSessions :many
SELECT id, user_id, refresh_token_hash, ip_address, device_name, user_agent, os_info,
       is_active, created_at, expires_at
FROM auth_session 
WHERE user_id = $1 AND is_active = TRUE AND expires_at > NOW()
ORDER BY created_at DESC
`

func (q *Queries) GetUserActiveSessions(ctx context.Context, db DBTX, userID string) ([]*AuthSession, error) {
	rows, err := db.Query(ctx, GetUserActiveSessions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*AuthSession{}
	for rows.Next() {
		var i AuthSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshTokenHash,
			&i.IpAddress,
			&i.DeviceName,
			&i.UserAgent,
			&i.OsInfo,
			&i.IsActive,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetVerificationToken = `-- name: GetVerificationToken :one
SELECT id, user_id, token_type, created_at, valid_till
FROM verification_token 
WHERE id = $1 AND valid_till > NOW()
`

func (q *Queries) GetVerificationToken(ctx context.Context, db DBTX, id string) (*VerificationToken, error) {
	row := db.QueryRow(ctx, GetVerificationToken, id)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenType,
		&i.CreatedAt,
		&i.ValidTill,
	)
	return &i, err
}

const UpdateAuthSessionLastUsed = `-- name: UpdateAuthSessionLastUsed :exec
UPDATE auth_session 
SET last_used_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateAuthSessionLastUsed(ctx context.Context, db DBTX, id string) error {
	_, err := db.Exec(ctx, UpdateAuthSessionLastUsed, id)
	return err
}
