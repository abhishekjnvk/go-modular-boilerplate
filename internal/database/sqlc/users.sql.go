// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountUsers = `-- name: CountUsers :one
SELECT COUNT(*) 
FROM users 
WHERE vendor_id = $1 AND is_active = TRUE
`

func (q *Queries) CountUsers(ctx context.Context, db DBTX, vendorID string) (int64, error) {
	row := db.QueryRow(ctx, CountUsers, vendorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateUser = `-- name: CreateUser :one
INSERT INTO users (id, name, email, password_hash, vendor_id, country, city, signup_source)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, name, email, email_verified, vendor_id, country, city, 
          is_active, is_disabled, enable_social_login, signup_source, created_at
`

type CreateUserParams struct {
	ID           string  `db:"id" json:"id"`
	Name         *string `db:"name" json:"name"`
	Email        string  `db:"email" json:"email"`
	PasswordHash string  `db:"password_hash" json:"password_hash"`
	VendorID     string  `db:"vendor_id" json:"vendor_id"`
	Country      *string `db:"country" json:"country"`
	City         *string `db:"city" json:"city"`
	SignupSource *string `db:"signup_source" json:"signup_source"`
}

type CreateUserRow struct {
	ID                string             `db:"id" json:"id"`
	Name              *string            `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) CreateUser(ctx context.Context, db DBTX, arg *CreateUserParams) (*CreateUserRow, error) {
	row := db.QueryRow(ctx, CreateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.PasswordHash,
		arg.VendorID,
		arg.Country,
		arg.City,
		arg.SignupSource,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const DeactivateUser = `-- name: DeactivateUser :exec
UPDATE users 
SET is_active = FALSE
WHERE id = $1
`

func (q *Queries) DeactivateUser(ctx context.Context, db DBTX, id string) error {
	_, err := db.Exec(ctx, DeactivateUser, id)
	return err
}

const GetUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, password_hash, email_verified, vendor_id, country, city,
       is_active, is_disabled, enable_social_login, signup_source, created_at
FROM users 
WHERE email = $1 AND vendor_id = $2 AND is_active = TRUE
`

type GetUserByEmailParams struct {
	Email    string `db:"email" json:"email"`
	VendorID string `db:"vendor_id" json:"vendor_id"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, db DBTX, arg *GetUserByEmailParams) (*User, error) {
	row := db.QueryRow(ctx, GetUserByEmail, arg.Email, arg.VendorID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.PasswordHash,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const GetUserByID = `-- name: GetUserByID :one
SELECT id, name, email, email_verified, vendor_id, country, city, 
       is_active, is_disabled, enable_social_login, signup_source, created_at
FROM users 
WHERE id = $1 AND is_active = TRUE
`

type GetUserByIDRow struct {
	ID                string             `db:"id" json:"id"`
	Name              *string            `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) GetUserByID(ctx context.Context, db DBTX, id string) (*GetUserByIDRow, error) {
	row := db.QueryRow(ctx, GetUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const ListUsers = `-- name: ListUsers :many
SELECT id, name, email, email_verified, vendor_id, country, city,
       is_active, is_disabled, enable_social_login, signup_source, created_at
FROM users 
WHERE vendor_id = $1 AND is_active = TRUE
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersParams struct {
	VendorID string `db:"vendor_id" json:"vendor_id"`
	Limit    int32  `db:"limit" json:"limit"`
	Offset   int32  `db:"offset" json:"offset"`
}

type ListUsersRow struct {
	ID                string             `db:"id" json:"id"`
	Name              *string            `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) ListUsers(ctx context.Context, db DBTX, arg *ListUsersParams) ([]*ListUsersRow, error) {
	rows, err := db.Query(ctx, ListUsers, arg.VendorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUsersRow{}
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.EmailVerified,
			&i.VendorID,
			&i.Country,
			&i.City,
			&i.IsActive,
			&i.IsDisabled,
			&i.EnableSocialLogin,
			&i.SignupSource,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateUser = `-- name: UpdateUser :one
UPDATE users 
SET name = COALESCE($2, name),
    email = COALESCE($3, email),
    country = COALESCE($4, country),
    city = COALESCE($5, city),
    email_verified = COALESCE($6, email_verified),
    enable_social_login = COALESCE($7, enable_social_login)
WHERE id = $1 AND is_active = TRUE
RETURNING id, name, email, email_verified, vendor_id, country, city, 
          is_active, is_disabled, enable_social_login, signup_source, created_at
`

type UpdateUserParams struct {
	ID                string  `db:"id" json:"id"`
	Name              *string `db:"name" json:"name"`
	Email             string  `db:"email" json:"email"`
	Country           *string `db:"country" json:"country"`
	City              *string `db:"city" json:"city"`
	EmailVerified     *bool   `db:"email_verified" json:"email_verified"`
	EnableSocialLogin *bool   `db:"enable_social_login" json:"enable_social_login"`
}

type UpdateUserRow struct {
	ID                string             `db:"id" json:"id"`
	Name              *string            `db:"name" json:"name"`
	Email             string             `db:"email" json:"email"`
	EmailVerified     *bool              `db:"email_verified" json:"email_verified"`
	VendorID          string             `db:"vendor_id" json:"vendor_id"`
	Country           *string            `db:"country" json:"country"`
	City              *string            `db:"city" json:"city"`
	IsActive          *bool              `db:"is_active" json:"is_active"`
	IsDisabled        *bool              `db:"is_disabled" json:"is_disabled"`
	EnableSocialLogin *bool              `db:"enable_social_login" json:"enable_social_login"`
	SignupSource      *string            `db:"signup_source" json:"signup_source"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, db DBTX, arg *UpdateUserParams) (*UpdateUserRow, error) {
	row := db.QueryRow(ctx, UpdateUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Country,
		arg.City,
		arg.EmailVerified,
		arg.EnableSocialLogin,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.EmailVerified,
		&i.VendorID,
		&i.Country,
		&i.City,
		&i.IsActive,
		&i.IsDisabled,
		&i.EnableSocialLogin,
		&i.SignupSource,
		&i.CreatedAt,
	)
	return &i, err
}

const UpdateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users 
SET password_hash = $2
WHERE id = $1 AND is_active = TRUE
`

type UpdateUserPasswordParams struct {
	ID           string `db:"id" json:"id"`
	PasswordHash string `db:"password_hash" json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, db DBTX, arg *UpdateUserPasswordParams) error {
	_, err := db.Exec(ctx, UpdateUserPassword, arg.ID, arg.PasswordHash)
	return err
}
